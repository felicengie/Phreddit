{"ast":null,"code":"var _jsxFileName = \"/Users/felice/Documents/project-habibi/client/src/components/functions.js\";\nimport React from 'react';\nimport { UsePhredditContext } from './phredditContext';\nimport { deleteComment, fetchPost, fetchComment, deletePost, updateComment, updatePost } from './api';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nexport function displayPosts({\n  showCommunityName = true,\n  posts\n}) {\n  const {\n    currentPage,\n    communities,\n    comments,\n    linkflairs,\n    loadPage,\n    user\n  } = UsePhredditContext();\n  let memberPosts = [];\n  let nonMemberPosts = [];\n  if (user && (currentPage === \"home\" || currentPage === \"searchResults\")) {\n    // Separate posts into two categories based on membership\n    memberPosts = posts.filter(post => {\n      const community = communities.find(c => c.postIDs.includes(post._id));\n      return community === null || community === void 0 ? void 0 : community.members.includes(user.displayName);\n    });\n    nonMemberPosts = posts.filter(post => {\n      const community = communities.find(c => c.postIDs.includes(post._id));\n      return !(community !== null && community !== void 0 && community.members.includes(user.displayName));\n    });\n  }\n  const renderPosts = (postArray, label) => {\n    if (postArray.length === 0) return null; // Do not render section if no posts\n\n    return /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [label && /*#__PURE__*/_jsxDEV(\"h3\", {\n        className: \"post-section-label\",\n        children: label\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 31,\n        columnNumber: 19\n      }, this), postArray.map(post => {\n        var _linkflairs$find;\n        const community = communities.find(c => c.postIDs.includes(post._id));\n        const postUser = post.createdBy;\n        const postTime = getTimeDifference(post.postedDate.toLocaleString());\n        const postFlair = ((_linkflairs$find = linkflairs.find(f => f._id === post.linkFlairID)) === null || _linkflairs$find === void 0 ? void 0 : _linkflairs$find.content) || '';\n        const commentCount = calculateCommentCount(post, comments);\n        const communityName = showCommunityName ? `${(community === null || community === void 0 ? void 0 : community.name) || 'Unknown Community'} | ` : '';\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"card-list\",\n          children: /*#__PURE__*/_jsxDEV(\"a\", {\n            href: \"#\",\n            className: \"post-link\",\n            onClick: e => {\n              e.preventDefault();\n              loadPage('post', null, post._id);\n            },\n            children: /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"card\",\n              children: [/*#__PURE__*/_jsxDEV(\"div\", {\n                className: \"post-header\",\n                children: [communityName, postUser, \" | \", postTime]\n              }, void 0, true, {\n                fileName: _jsxFileName,\n                lineNumber: 52,\n                columnNumber: 19\n              }, this), /*#__PURE__*/_jsxDEV(\"h2\", {\n                className: \"post-title\",\n                children: post.title\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 53,\n                columnNumber: 19\n              }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n                children: postFlair\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 54,\n                columnNumber: 19\n              }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n                children: [post.content.substring(0, 80), \"...\"]\n              }, void 0, true, {\n                fileName: _jsxFileName,\n                lineNumber: 55,\n                columnNumber: 19\n              }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n                children: [\"Views: \", post.views, \" | Comments: \", commentCount, \" | Vote Count: \", post.upvoters.length - post.downvoters.length, \" \"]\n              }, void 0, true, {\n                fileName: _jsxFileName,\n                lineNumber: 56,\n                columnNumber: 19\n              }, this)]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 51,\n              columnNumber: 17\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 43,\n            columnNumber: 15\n          }, this)\n        }, post._id, false, {\n          fileName: _jsxFileName,\n          lineNumber: 42,\n          columnNumber: 13\n        }, this);\n      })]\n    }, void 0, true);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"post-list\",\n    children: user && (currentPage === \"home\" || currentPage === \"searchResults\") ? /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [renderPosts(memberPosts, \"Posts from Communities You Are Part Of\"), renderPosts(nonMemberPosts, \"Other Posts\")]\n    }, void 0, true) : renderPosts(posts) // No filtering, just render posts as-is\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 68,\n    columnNumber: 5\n  }, this);\n}\nexport function getTimeDifference(submittedDate) {\n  const now = new Date(); // Current date and time\n  const submitted = new Date(submittedDate); // The date the item was submitted\n\n  const diffInSeconds = Math.floor((now - submitted) / 1000); // Difference in seconds\n\n  // Less than 1 minute (seconds)\n  if (diffInSeconds < 60) {\n    return `${diffInSeconds} seconds ago`;\n  }\n\n  // Less than 1 hour (minutes)\n  const diffInMinutes = Math.floor(diffInSeconds / 60);\n  if (diffInMinutes < 60) {\n    return `${diffInMinutes} minutes ago`;\n  }\n\n  // Less than 24 hours (hours)\n  const diffInHours = Math.floor(diffInMinutes / 60);\n  if (diffInHours < 24) {\n    return `${diffInHours} hours ago`;\n  }\n\n  // Less than 30 days (days)\n  const diffInDays = Math.floor(diffInHours / 24);\n  if (diffInDays < 30) {\n    return `${diffInDays} days ago`;\n  }\n\n  // Less than 12 months (months)\n  const diffInMonths = Math.floor(diffInDays / 30);\n  if (diffInMonths < 12) {\n    return `${diffInMonths} month(s) ago`;\n  }\n\n  // More than 1 year (years)\n  const diffInYears = Math.floor(diffInMonths / 12);\n  return `${diffInYears} year(s) ago`;\n}\n\n// sortPosts.js\nexport function sortPosts(posts, type, comments) {\n  let sortedPosts = [];\n  switch (type) {\n    case 'newest':\n      sortedPosts = [...posts].sort((a, b) => new Date(b.postedDate) - new Date(a.postedDate));\n      break;\n    case 'oldest':\n      sortedPosts = [...posts].sort((a, b) => new Date(a.postedDate) - new Date(b.postedDate));\n      break;\n    case 'active':\n      // Sort by the latest comment date (including replies)\n      sortedPosts = [...posts].sort((a, b) => {\n        const latestCommentA = Math.max(...a.commentIDs.map(commentID => getLatestCommentDate(commentID, comments)));\n        const latestCommentB = Math.max(...b.commentIDs.map(commentID => getLatestCommentDate(commentID, comments)));\n        return latestCommentB - latestCommentA; // Sort descending\n      });\n      break;\n    default:\n      sortedPosts = posts;\n  }\n  return sortedPosts;\n}\n\n// Helper function to recursively find the latest comment date (including replies)\nexport function getLatestCommentDate(commentID, comments) {\n  const comment = comments.find(c => c._id === commentID);\n\n  // Get the latest date of the current comment\n  let latestDate = new Date(comment.commentedDate).getTime();\n\n  // Recursively check all replies to this comment (if any) and update the latest date\n  comment.commentIDs.forEach(replyID => {\n    const replyDate = getLatestCommentDate(replyID, comments); // Recursive call for replies\n    if (replyDate > latestDate) {\n      latestDate = replyDate;\n    }\n  });\n  return latestDate;\n}\nexport function calculateCommentCount(post, comments) {\n  // Helper function to count comments recursively\n  //console.log(\"POST\", post)\n  // console.log(\"comments: \", comments)\n  const countReplies = commentIDs => {\n    let totalCount = 0;\n    commentIDs.forEach(id => {\n      const comment = comments.find(c => c._id === id);\n      //console.log(\"found comment:\", comment)\n      if (comment) {\n        totalCount += 1 + countReplies(comment.commentIDs);\n      }\n    });\n    return totalCount;\n  };\n  return countReplies(post.commentIDs);\n}\n\n// export const deleteCommentsRecursively = async (comment) => {\n//   const {comments, setComments} = UsePhredditContext()\n//   console.log(comment)\n//   try {\n//     // If the comment has replies (commentIDs), recursively delete those first\n//     if (comment.commentIDs && comment.commentIDs.length > 0) {\n//       for (const replyId of comment.commentIDs) {\n//         const reply = comments.find((r) => r._id === replyId);\n//         await deleteCommentsRecursively(reply); // Recursively delete each reply\n//       }\n//     }\n\n//     // Now that all replies are deleted, delete the current comment\n//     await deleteComment(comment._id);\n//     console.log(`Deleted comment with ID: ${comment._id}`);\n\n//     // Optionally, remove the deleted comment from the state to update the UI\n//     // This assumes you have a state like 'comments' where you store the comments list\n//     setComments((prevComments) =>\n//       prevComments.filter((c) => c._id !== comment._id)\n//     );\n//     console.log(`comments array: ${comments}`);\n\n//   } catch (error) {\n//     console.error('Error deleting comment:', error);\n//   }\n// };\n\n// export const deletePosts = async (postIDs) => {\n//   const {setPosts, posts} = UsePhredditContext()\n//   try {\n//       for (const postID of postIDs) {\n//         console.log(`Deleting post with ID: ${postID}`);\n\n//         const post = await fetchPost(postID);\n//         if (!post) {\n//           console.warn(`Post with ID: ${postID} not found or already deleted.`);\n//           return;\n//         }\n\n//         console.log(`Post with ID: ${postID} fetched successfully.`);\n\n//         // Step 2: Fetch and recursively delete associated comments\n//           if (post.commentIDs && post.commentIDs.length > 0) {\n//               console.log(`Processing ${post.commentIDs.length} comments associated with the post.`);\n//               for (const commentID of post.commentIDs) {\n//               console.log(\"CommentID: \", commentID)\n//               const comment = await fetchComment(commentID);\n//               if (comment) {\n//                   await deleteCommentsRecursively(comment); // Call the recursive function directly\n//               }\n//               }\n//           }\n//         // Call the API to delete the post\n//           await deletePost(postID); // Ensure `deletePost` is implemented to make an API request\n//           // Update the state to remove the deleted post\n//           setPosts((prevPosts) =>\n//               prevPosts.filter((p) => p._id !== postID)\n//           );\n//           console.log(`Post with ID: ${postID} deleted successfully.`);\n//       }\n//       console.log(\"All posts in the community have been deleted.\");\n//       console.log(\"posts array now: \", posts)\n\n//   } catch (error) {\n//       console.error(\"Error deleting posts:\", error);\n//   }\n// }\n\nexport function usePostDeletion() {\n  const {\n    setPosts,\n    setComments,\n    posts,\n    comments\n  } = UsePhredditContext();\n  const deleteCommentsRecursively = async comment => {\n    try {\n      if (comment.commentIDs && comment.commentIDs.length > 0) {\n        for (const replyId of comment.commentIDs) {\n          const reply = comments.find(r => r._id === replyId);\n          if (reply) await deleteCommentsRecursively(reply); // Recursive call\n        }\n      }\n      await deleteComment(comment._id);\n      setComments(prevComments => prevComments.filter(c => c._id !== comment._id));\n      const parentComment = comments.find(parent => parent.commentIDs.includes(comment._id));\n      if (parentComment) {\n        // Remove the current comment's _id from the parent's commentIDs array\n        const updatedCommentIDs = parentComment.commentIDs.filter(id => id !== comment._id);\n\n        // Make an API call to update the parent comment in the database\n        try {\n          await updateComment(parentComment._id, {\n            commentIDs: updatedCommentIDs\n          });\n          console.log(`Parent comment ${parentComment._id} updated successfully in the database.`);\n        } catch (error) {\n          console.error(`Error updating parent comment ${parentComment._id}:`, error);\n          return;\n        }\n\n        // Update the parent comment in the state\n        setComments(prevComments => prevComments.map(c => c._id === parentComment._id ? {\n          ...c,\n          commentIDs: updatedCommentIDs\n        } : c));\n      }\n      const post = posts.find(p => p.commentIDs && p.commentIDs.includes(comment._id));\n      if (post) {\n        // Remove the deleted comment _id from the post's commentIDs array\n        const updatedCommentIDs = post.commentIDs.filter(id => id !== comment._id);\n\n        // Make an API call to update the post in the database\n        try {\n          await updatePost(post._id, {\n            commentIDs: updatedCommentIDs\n          });\n          console.log(`Post ${post._id} updated successfully in the database.`);\n        } catch (error) {\n          console.error(`Error updating post ${post._id}:`, error);\n          return; // Optionally handle this error to avoid further processing\n        }\n\n        // Update the post in the state\n        setPosts(prevPosts => prevPosts.map(p => p._id === post._id ? {\n          ...p,\n          commentIDs: updatedCommentIDs\n        } : p));\n      }\n    } catch (error) {\n      console.error('Error deleting comment:', error);\n    }\n  };\n  const deletePosts = async postIDs => {\n    try {\n      for (const postID of postIDs) {\n        const post = await fetchPost(postID);\n        if (!post) {\n          console.warn(`Post with ID: ${postID} not found or already deleted.`);\n          continue;\n        }\n        if (post.commentIDs && post.commentIDs.length > 0) {\n          for (const commentID of post.commentIDs) {\n            const comment = await fetchComment(commentID);\n            if (comment) {\n              await deleteCommentsRecursively(comment);\n            }\n          }\n        }\n        console.log(comments);\n        await deletePost(postID);\n        setPosts(prevPosts => prevPosts.filter(p => p._id !== postID));\n      }\n    } catch (error) {\n      console.error('Error deleting posts:', error);\n    }\n  };\n  return {\n    deleteCommentsRecursively,\n    deletePosts\n  };\n}","map":{"version":3,"names":["React","UsePhredditContext","deleteComment","fetchPost","fetchComment","deletePost","updateComment","updatePost","jsxDEV","_jsxDEV","Fragment","_Fragment","displayPosts","showCommunityName","posts","currentPage","communities","comments","linkflairs","loadPage","user","memberPosts","nonMemberPosts","filter","post","community","find","c","postIDs","includes","_id","members","displayName","renderPosts","postArray","label","length","children","className","fileName","_jsxFileName","lineNumber","columnNumber","map","_linkflairs$find","postUser","createdBy","postTime","getTimeDifference","postedDate","toLocaleString","postFlair","f","linkFlairID","content","commentCount","calculateCommentCount","communityName","name","href","onClick","e","preventDefault","title","substring","views","upvoters","downvoters","submittedDate","now","Date","submitted","diffInSeconds","Math","floor","diffInMinutes","diffInHours","diffInDays","diffInMonths","diffInYears","sortPosts","type","sortedPosts","sort","a","b","latestCommentA","max","commentIDs","commentID","getLatestCommentDate","latestCommentB","comment","latestDate","commentedDate","getTime","forEach","replyID","replyDate","countReplies","totalCount","id","usePostDeletion","setPosts","setComments","deleteCommentsRecursively","replyId","reply","r","prevComments","parentComment","parent","updatedCommentIDs","console","log","error","p","prevPosts","deletePosts","postID","warn"],"sources":["/Users/felice/Documents/project-habibi/client/src/components/functions.js"],"sourcesContent":["\nimport React from 'react';\nimport { UsePhredditContext } from './phredditContext';\nimport { deleteComment, fetchPost, fetchComment, deletePost, updateComment, updatePost } from './api';\n\n\nexport function displayPosts({ showCommunityName = true, posts }) {\n  const { currentPage, communities, comments, linkflairs, loadPage, user } = UsePhredditContext();\n  let memberPosts = [];\n  let nonMemberPosts = [];\n\n  if(user && (currentPage === \"home\" || currentPage === \"searchResults\")){\n    // Separate posts into two categories based on membership\n      memberPosts = posts.filter(post => {\n      const community = communities.find(c => c.postIDs.includes(post._id));\n      return community?.members.includes(user.displayName);\n    });\n\n      nonMemberPosts = posts.filter(post => {\n      const community = communities.find(c => c.postIDs.includes(post._id));\n      return !community?.members.includes(user.displayName);\n    });\n\n  }\n \n  const renderPosts = (postArray, label) => {\n    if (postArray.length === 0) return null; // Do not render section if no posts\n\n    return (\n      <>\n        {label && <h3 className=\"post-section-label\">{label}</h3>}\n        {postArray.map(post => {\n          const community = communities.find(c => c.postIDs.includes(post._id));\n          const postUser = post.createdBy;\n          const postTime = getTimeDifference(post.postedDate.toLocaleString());\n          const postFlair = linkflairs.find(f => f._id === post.linkFlairID)?.content || '';\n          const commentCount = calculateCommentCount(post, comments);\n\n          const communityName = showCommunityName ? `${community?.name || 'Unknown Community'} | ` : '';\n\n          return (\n            <div key={post._id} className=\"card-list\">\n              <a\n                href=\"#\"\n                className=\"post-link\"\n                onClick={e => {\n                  e.preventDefault();\n                  loadPage('post', null, post._id);\n                }}\n              >\n                <div className = \"card\">\n                  <div className=\"post-header\">{communityName}{postUser} | {postTime}</div>\n                  <h2 className=\"post-title\">{post.title}</h2>\n                  <p>{postFlair}</p>\n                  <p>{post.content.substring(0, 80)}...</p>\n                  <div>Views: {post.views} | Comments: {commentCount} | Vote Count: {post.upvoters.length - post.downvoters.length} </div>\n                </div>\n              </a>\n            </div>\n          );\n        })}\n      </>\n    );\n  };\n\n\n  return (\n    <div className=\"post-list\">\n      {user && (currentPage === \"home\" || currentPage === \"searchResults\") ? (\n        <>\n          {renderPosts(memberPosts, \"Posts from Communities You Are Part Of\")}\n          {renderPosts(nonMemberPosts, \"Other Posts\")}\n        </>\n      ) : (\n        renderPosts(posts) // No filtering, just render posts as-is\n      )}\n    </div>\n  );\n}\n\n\nexport function getTimeDifference(submittedDate) {\n    const now = new Date();  // Current date and time\n    const submitted = new Date(submittedDate);  // The date the item was submitted\n    \n    const diffInSeconds = Math.floor((now - submitted) / 1000);  // Difference in seconds\n    \n    // Less than 1 minute (seconds)\n    if (diffInSeconds < 60) {\n      return `${diffInSeconds} seconds ago`;\n    }\n  \n    // Less than 1 hour (minutes)\n    const diffInMinutes = Math.floor(diffInSeconds / 60);\n    if (diffInMinutes < 60) {\n      return `${diffInMinutes} minutes ago`;\n    }\n  \n    // Less than 24 hours (hours)\n    const diffInHours = Math.floor(diffInMinutes / 60);\n    if (diffInHours < 24) {\n      return `${diffInHours} hours ago`;\n    }\n  \n    // Less than 30 days (days)\n    const diffInDays = Math.floor(diffInHours / 24);\n    if (diffInDays < 30) {\n      return `${diffInDays} days ago`;\n    }\n  \n    // Less than 12 months (months)\n    const diffInMonths = Math.floor(diffInDays / 30);\n    if (diffInMonths < 12) {\n      return `${diffInMonths} month(s) ago`;\n    }\n  \n    // More than 1 year (years)\n    const diffInYears = Math.floor(diffInMonths / 12);\n    return `${diffInYears} year(s) ago`;\n  }\n\n  // sortPosts.js\nexport function sortPosts(posts, type, comments) {\n    let sortedPosts = [];\n    switch (type) {\n      case 'newest':\n        sortedPosts = [...posts].sort((a, b) => new Date(b.postedDate) - new Date(a.postedDate));\n        break;\n      case 'oldest':\n        sortedPosts = [...posts].sort((a, b) => new Date(a.postedDate) - new Date(b.postedDate));\n        break;\n        case 'active':\n          // Sort by the latest comment date (including replies)\n          sortedPosts = [...posts].sort((a, b) => {\n              const latestCommentA = Math.max(...a.commentIDs.map(commentID => getLatestCommentDate(commentID, comments)));\n              const latestCommentB = Math.max(...b.commentIDs.map(commentID => getLatestCommentDate(commentID, comments)));\n              return latestCommentB - latestCommentA; // Sort descending\n          });\n          break;\n      default:\n        sortedPosts = posts;\n    }\n    return sortedPosts;\n  }\n  \n  // Helper function to recursively find the latest comment date (including replies)\nexport function getLatestCommentDate(commentID, comments) {\n  const comment = comments.find(c => c._id === commentID);\n\n  // Get the latest date of the current comment\n  let latestDate = new Date(comment.commentedDate).getTime();\n\n  // Recursively check all replies to this comment (if any) and update the latest date\n  comment.commentIDs.forEach(replyID => {\n      const replyDate = getLatestCommentDate(replyID, comments); // Recursive call for replies\n      if (replyDate > latestDate) {\n          latestDate = replyDate;\n      }\n  });\n\n  return latestDate;\n}\n\n  export function calculateCommentCount(post, comments) {\n    // Helper function to count comments recursively\n    //console.log(\"POST\", post)\n    // console.log(\"comments: \", comments)\n    const countReplies = (commentIDs) => { \n      let totalCount = 0;\n      commentIDs.forEach(id => {\n        const comment = comments.find(c => c._id === id);\n        //console.log(\"found comment:\", comment)\n        if (comment) { totalCount += 1 + countReplies(comment.commentIDs); }\n      });\n      return totalCount;\n    };\n    return countReplies(post.commentIDs);\n  }\n\n\n  // export const deleteCommentsRecursively = async (comment) => {\n  //   const {comments, setComments} = UsePhredditContext()\n  //   console.log(comment)\n  //   try {\n  //     // If the comment has replies (commentIDs), recursively delete those first\n  //     if (comment.commentIDs && comment.commentIDs.length > 0) {\n  //       for (const replyId of comment.commentIDs) {\n  //         const reply = comments.find((r) => r._id === replyId);\n  //         await deleteCommentsRecursively(reply); // Recursively delete each reply\n  //       }\n  //     }\n  \n  //     // Now that all replies are deleted, delete the current comment\n  //     await deleteComment(comment._id);\n  //     console.log(`Deleted comment with ID: ${comment._id}`);\n  \n  //     // Optionally, remove the deleted comment from the state to update the UI\n  //     // This assumes you have a state like 'comments' where you store the comments list\n  //     setComments((prevComments) =>\n  //       prevComments.filter((c) => c._id !== comment._id)\n  //     );\n  //     console.log(`comments array: ${comments}`);\n      \n  //   } catch (error) {\n  //     console.error('Error deleting comment:', error);\n  //   }\n  // };\n\n  // export const deletePosts = async (postIDs) => {\n  //   const {setPosts, posts} = UsePhredditContext()\n  //   try {\n  //       for (const postID of postIDs) {\n  //         console.log(`Deleting post with ID: ${postID}`);\n            \n  //         const post = await fetchPost(postID);\n  //         if (!post) {\n  //           console.warn(`Post with ID: ${postID} not found or already deleted.`);\n  //           return;\n  //         }\n          \n  //         console.log(`Post with ID: ${postID} fetched successfully.`);\n\n  //         // Step 2: Fetch and recursively delete associated comments\n  //           if (post.commentIDs && post.commentIDs.length > 0) {\n  //               console.log(`Processing ${post.commentIDs.length} comments associated with the post.`);\n  //               for (const commentID of post.commentIDs) {\n  //               console.log(\"CommentID: \", commentID)\n  //               const comment = await fetchComment(commentID);\n  //               if (comment) {\n  //                   await deleteCommentsRecursively(comment); // Call the recursive function directly\n  //               }\n  //               }\n  //           }\n  //         // Call the API to delete the post\n  //           await deletePost(postID); // Ensure `deletePost` is implemented to make an API request\n  //           // Update the state to remove the deleted post\n  //           setPosts((prevPosts) =>\n  //               prevPosts.filter((p) => p._id !== postID)\n  //           );\n  //           console.log(`Post with ID: ${postID} deleted successfully.`);\n  //       }\n  //       console.log(\"All posts in the community have been deleted.\");\n  //       console.log(\"posts array now: \", posts)\n      \n  //   } catch (error) {\n  //       console.error(\"Error deleting posts:\", error);\n  //   }\n  // }\n\n\nexport function usePostDeletion() {\n  const { setPosts, setComments, posts, comments } = UsePhredditContext();\n\n  const deleteCommentsRecursively = async (comment) => {\n    try {\n      if (comment.commentIDs && comment.commentIDs.length > 0) {\n        for (const replyId of comment.commentIDs) {\n          const reply = comments.find((r) => r._id === replyId);\n          if (reply) await deleteCommentsRecursively(reply); // Recursive call\n        }\n      }\n      await deleteComment(comment._id);\n      setComments((prevComments) => prevComments.filter((c) => c._id !== comment._id));\n\n      const parentComment = comments.find((parent) => parent.commentIDs.includes(comment._id));\n      if (parentComment) {\n       // Remove the current comment's _id from the parent's commentIDs array\n    const updatedCommentIDs = parentComment.commentIDs.filter((id) => id !== comment._id);\n\n    // Make an API call to update the parent comment in the database\n        try {\n            await updateComment(parentComment._id, { commentIDs: updatedCommentIDs });\n            console.log(`Parent comment ${parentComment._id} updated successfully in the database.`);\n        } catch (error) {\n            console.error(`Error updating parent comment ${parentComment._id}:`, error);\n            return; \n        }\n\n        // Update the parent comment in the state\n        setComments((prevComments) =>\n            prevComments.map((c) =>\n                c._id === parentComment._id ? { ...c, commentIDs: updatedCommentIDs } : c\n            )\n        );\n      }\n\n      const post = posts.find((p) => p.commentIDs && p.commentIDs.includes(comment._id));\n      if (post) {\n          // Remove the deleted comment _id from the post's commentIDs array\n          const updatedCommentIDs = post.commentIDs.filter((id) => id !== comment._id);\n\n          // Make an API call to update the post in the database\n          try {\n              await updatePost(post._id, { commentIDs: updatedCommentIDs });\n              console.log(`Post ${post._id} updated successfully in the database.`);\n          } catch (error) {\n              console.error(`Error updating post ${post._id}:`, error);\n              return; // Optionally handle this error to avoid further processing\n          }\n\n          // Update the post in the state\n          setPosts((prevPosts) =>\n              prevPosts.map((p) =>\n                  p._id === post._id ? { ...p, commentIDs: updatedCommentIDs } : p\n              )\n          );\n        }\n\n\n    } catch (error) {\n      console.error('Error deleting comment:', error);\n    }\n  };\n\n  const deletePosts = async (postIDs) => {\n    try {\n      for (const postID of postIDs) {\n        const post = await fetchPost(postID);\n        if (!post) {\n          console.warn(`Post with ID: ${postID} not found or already deleted.`);\n          continue;\n        }\n\n        if (post.commentIDs && post.commentIDs.length > 0) {\n          for (const commentID of post.commentIDs) {\n            const comment = await fetchComment(commentID);\n            if (comment) {\n              await deleteCommentsRecursively(comment);\n            }\n          }\n        }\n\n        console.log(comments)\n\n        await deletePost(postID);\n        setPosts((prevPosts) => prevPosts.filter((p) => p._id !== postID));\n      }\n    } catch (error) {\n      console.error('Error deleting posts:', error);\n    }\n  };\n\n  return { deleteCommentsRecursively, deletePosts };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}